---
title: "dwplot: Dot-and-Whisker Plots of Regression Coefficients from Tidy Data Frames"
author: "Frederick Solt and Yue Hu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: vignette_dwplot.bib
vignette: >
  %\VignetteIndexEntry{dwplot: Dot-and-Whisker Plots of Regression Coefficients from Tidy Data Frames}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{ASCII}
---

Graphs have long been known to be a more compact and effective means of conveying the results of regression models than tables [@Gelman2002; @Kastellec2007], but many researchers continue to list these results in tables. The reason, @Kastellec2007 surmised, is "simply put, it takes much greater effort to produce a quality graph than a table." The `dotwhisker` package provides a convenient way to create highly customizable dot-and-whisker plots for presenting and comparing the output of regression models. It can be used to plot estimates of coefficients or other quantities of interest (e.g., predicted probabilities) within a single model or across different models: the estimates are presented as dots and their confidence intervals as whiskers [see @Kastellec2007, 765-767].

Users can easily customize the number of models, the exact variables presented, and the inverval between the compared estimates based on their interests and presenting demands. Moreover, by outputting `ggplot` objects [@Wickham2009], `dotwhisker` allows users to easily further modify their graphs.

This vignette illustrates basic use of `dwplot` for creating dot-and-whisker plots from model objects, more advanced uses of `dwplot` that employ tidy data.frames as input, and finally some popular variations of dot-and-whisker plots that are made easily using other functions in the `dotwhisker` package.

## Basic Use
Generating dot-and-whisker plots from model objects generated by `R`'s most commonly used regression functions is straightforward.  To make a basic dot-and-whisker plot of any single model object of a class supported by [`broom::tidy`](https://cran.r-project.org/web/packages/broom/index.html), simply pass it to `dwplot`:

```{r fig.width= 7, warning= FALSE, message= FALSE}
#Package preload
library(dotwhisker)

# run a regression compatible with tidy
data(mtcars)
m1 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars)

# draw a dot-and-whisker plot
dwplot(m1)
```

By default, the whiskers span the 95\% confidence interval.  To change the width of the confidence interval, use the `alpha` argument:

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1, alpha = .01)  # using 99% CI
```

Plotting the results of more than one regression model is just as easy.  Just pass the model objects to `dwplot` as a list:

```{r fig.width= 7, warning= FALSE, message= FALSE}
m2 <- update(m1, . ~ . + hp) # add another predictor
m3 <- update(m2, . ~ . + am) # and another 

dwplot(list(m1, m2, m3))
```

Moreover, the output of `dwplot` is a `ggplot` object. Add or change any `ggplot` layers after calling `dwplot` to achieve the desired presentation.

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(list(m1, m2, m3)) + 
    relabel_y_axis(c("Intercept", "Weight", "Cylinders", "Gears",
                     "Displacement", "Horsepower", "Manual")) +
    theme_bw() + xlab("Standardized Coefficient") + ylab("") +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    ggtitle("Predicting Gas Mileage") +
    theme(plot.title = element_text(face="bold"), legend.position="none") 
```

Note that providing a character vector to `relabel_y_axis`, a `dotwhisker` function, conveniently renames the predictors from top to bottom.

## Prepare a Data Frame for Graphing
To omit intercepts, rescale coefficients, etc., no change in the use of `dwplot` is required: one simply modifies the data frame, as described above, that is passed to the function. 

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df_sel2)
```


There are many other packages (e.g., `coefplot`) that have the ability to draw dot-and-whisker plots of at least a single set of regression results taking model objects as input. While this is very convenient, it also comes with some severe limitations.  First, many uncommon model objects are not supported.  Second, rescaling coefficients or plotting a subset of results is typically impossible.  And third, quantities of interest beyond coefficient estimates cannot be plotted.  The `dotwhisker` package avoids all of these limitations by optionally taking as its input a data frame of estimates drawn from a model object rather than the model object itself.  

The valid input object for `dotwhisker` is a data frame including three columns: `term`, that is, the variable name; `estimate`, the regression coefficients or other quantity of interest; and `std.error`, the standard errors associated with these estimates. In place of `std.error` one may substitute `lb`, the lower bounds of the confidence intervals of the estimates, and `ub`, the corresponding upper bounds. For many common models, one can use `broom::tidy` [@Robinson2015] to produce such a data frame of estimates (`dwplot` expects a data.frame with the columns `term`, `estimate`, and `std.error` because this is the format of the output produced by `tidy`).  

```{r fig.width=7, message=FALSE, warning=FALSE}
# regression compatible with tidy
m1_df <- tidy(m1) # create data.frame of regression results
m1_df # a tidy data.frame available for dwplot
dwplot(m1_df) #same as dwplot(m1)
```

It is easy to plot classes of model objects that are not compatible with `tidy`: one simply extracts the results and builds the data frame to pass to `dwplot` oneself. Many functions generate results that can be extracted by `coef()`.

```{r fig.width=7, message=FALSE, warning=FALSE}
library(dplyr)

# the ordinal regression model is not supported by tidy
m4 <- ordinal::clm(factor(gear) ~ wt + cyl + disp, data = mtcars)
m4_df <- coef(summary(m4)) %>% 
  data.frame() %>% 
  add_rownames("term") %>%
  rename(estimate = Estimate, std.error = Std..Error)
m4_df
dwplot(m4_df)
```

It is similarly straightforward to rescale or reorder coefficients or to plot just a subset of results. After creating a tidy data frame, users are free to select or delete variables or to change their order. In many cases, for example, users will wish to consider omitting model intercepts as they are rarely theoretically interesting [see @Kastellec2007, 765]. Another often desireable manipulation is to standardize the scales of variables. @Gelman2008, for example, suggests rescaling ordinal and continuous predictors by two standard deviations to facilitate comparison with dichotomous predictors. Although this of course can be done before model estimation, it can be convenient to simply rescale the coefficients afterwards; the `by_2sd` function, which takes as arguments a data frame of estimates along with the original data frame upon which the model was based, automates this calculation.

```{r fig.width=7, message=FALSE, warning=FALSE}
# Customize the input data frame
m1_df  # the original tidy data.frame

m1_df_mod <- tidy(m1) %>% by_2sd(mtcars) %>%   # rescale the coefficients
    filter(term != "(Intercept)") %>%          # omit intercept
    arrange(term)                              # alphabetize the variables

m1_df_mod  # rescaled, intercept omitted, and variables reordered alphabetically
dwplot(m1_df_mod)
```

An input data frame can also be constructed from estimates of other quantities of interest, such as margins, odds ratios, or predicted probabilities, rather than coefficients. 

```{r fig.width=7, message=FALSE, warning=FALSE}
# Create a data.frame of marginal effects
library(mfx)
m5 <- logitmfx(formula = am ~ wt + cyl + disp, data = mtcars) 
m5_margin <- data.frame(m5$mfxest) %>% 
  add_rownames("term") %>% 
  rename(estimate = dF.dx, std.error = Std..Err.)
m5_margin
dwplot(m5_margin)
```

```{r fig.width=7, message=FALSE, warning=FALSE}
m6 <- glm(formula = am ~ wt + cyl + disp, data = mtcars, family = "binomial")

# make a tidy data.frame of odds ratios
m6_se <- sqrt(diag(vcov(m1)))
m6_or_df <- data.frame(exp(cbind(estimate = coef(m1), std.error = coef(m1) * sqrt(diag(vcov(m1))))))
m6_or_df$term <- row.names(m1_or_df)

dwplot(m6_or_df)
```

## Plot Estimates with `dwplot`

The `dotwhisker::dwplot` function is very easy to use. It takes just three arguments: `df`, `alpha`, and `dodge_size`.  The `df` argument is the data frame of estimates to be plotted (as described above). The `alpha` argument is the significance level of the confidence intervals to be spanned by the whiskers: its default value is .05, implying a 95% confidence interval. The `dodge_size` argument is used to adjust the space between the estimates of one variable when  multiple models are presented in a single plot.  Its default value will work fine, but more pleasing results can sometimes by achieved by it to lower values when the plotted results include a smaller number of predictors.

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df)
dwplot(m1_df, alpha = .01)  # using 99% CI
```

To omit intercepts, rescale coefficients, etc., no change in the use of `dwplot` is required: one simply modifies the data frame, as described above, that is passed to the function. 

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df_sel2)
```

Moreover, the output of `dwplot` is a `ggplot` object. Therefore, users are able to add or change any `ggplot` layers after calling `dwplot` to achieve the desired presentation.

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df_sel2) + 
    scale_y_discrete(breaks = 4:1, 
                      labels=c("Cylinders", "Displacement", "Gears", "Weight")) +
    theme_bw() + xlab("Standardized Coefficient") + ylab("") +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    ggtitle("Predicting Gas Mileage") +
    theme(plot.title = element_text(face="bold"), legend.position="none") 
```



## Compare Across Models 
An additional advantage of `dwplot` over alternative solutions is that it can be used to create plots that present multiple models---across different samples or specifications---in little space while also facilitating cross-model comparisons. To do this, one first needs to append the data frame of estimates from the new model to that of the old model and create an additional column `model` that identifies the two models.

```{r fig.width= 7, fig.height=5, warning=FALSE, message=FALSE}
# Run model on subsets of data, save results as tidy df, drop intercept, and make model variable
by_trans <- mtcars %>% group_by(am) %>%
    do(tidy(lm(mpg ~ wt + cyl + disp + gear, data = .))) %>%
    filter(term != "(Intercept)") %>% rename(model=am)

by_trans

dwplot(by_trans, dodge_size = .05) +
    scale_y_discrete(breaks = 4:1, labels=c("Weight", "Cylinders", "Displacement", "Gears")) +
    theme_bw() + xlab("Coefficient Estimate") + ylab("") +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    ggtitle("Predicting Gas Mileage by Transmission Type") +
    theme(plot.title = element_text(face="bold"),
          legend.justification=c(0, 0), legend.position=c(0, 0),
          legend.background = element_rect(colour="grey80"),
          legend.title.align = .5) +
    scale_colour_grey(start = .4, end = .8,
                      name = "Transmission",
                      breaks = c(0, 1),
                      labels = c("Automatic", "Manual"))

```

To include models with different predictors, one must ensure the `term`s are identical across all of the models.  That is, the data frame for each model must include a row for every predictor included in any of the models, in the same order, regardless of whether the predictor is actually included in a particular model.  Quantities not estimated in a particular model should be assigned a value of `NA`.

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
# Estimate three models
m4 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars) # same as m1
m5 <- update(m4, . ~ . + hp) # add another predictor
m6 <- update(m5, . ~ . + am) # and another 

# Tidy estimates, rescale, and omit intercepts
prep <- . %>% tidy() %>% by_2sd(mtcars) %>% filter(term != "(Intercept)")

m4_df <- prep(m4)
m5_df <- prep(m5)
m6_df <- prep(m6)

# Ensure all data.frames include rows for all of the predictors, in the same order
# Include NAs for any quantities not estimated in a particular model
m4_df <- rbind(m4_df, c("hp", rep(NA, times = ncol(m4_df) - 1)),
               c("am", rep(NA, times = ncol(m4_df) - 1)))
m5_df <- rbind(m5_df, c("am", rep(NA, times = ncol(m5_df) - 1)))

# Add model variable to all data frames
m4_df <- mutate(m4_df, model = "Model 4")
m5_df <- mutate(m5_df, model = "Model 5")
m6_df <- mutate(m6_df, model = "Model 6")

m456_df <- rbind(m4_df, m5_df, m6_df)

dwplot(m456_df, dodge_size = .08) +
     scale_y_discrete(breaks = 6:1, 
                      labels=c("Weight", "Cylinders", "Displacement", 
                               "Gears", "Horsepower", "Manual")) +
     theme_bw() + xlab("Coefficient Estimate") + ylab("") +
     geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
     ggtitle("Predicting Gas Mileage") +
     theme(plot.title = element_text(face="bold"),
           legend.justification=c(1, 1), legend.position=c(1, 1),
           legend.background = element_rect(colour="grey80"),
           legend.title = element_blank()) 
```

It is frequently desirable to convey to an audience that the predictors in a model depicted in a dot-and-whisker plot form groups of some sort.  This can be achieved by passing the finalized plot to the `add_brackets` function.  Note that `add_brackets` outputs a `gtable` rather than a `ggplot` object.  Therefore, the output is displayed using `grid.draw` and saved, at present, by calling a device.

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
# Reorder predictors into groups
ordered_vars <- c("wt", "cyl", "disp", "hp", "gear", "am")
m456_df <- m456_df %>% 
    mutate(term =  factor(term, levels = ordered_vars)) %>%
    group_by(model) %>% arrange(term) 

# Save finalized plot to an object (note reordered labels to match reordered predictors)
p456 <- dwplot(m456_df, dodge_size = .08) +
     scale_y_discrete(breaks = 6:1, 
                      labels=c("Weight", "Cylinders", "Displacement", 
                               "Horsepower", "Gears", "Manual")) +
     theme_bw() + xlab("Coefficient Estimate") + ylab("") +
     geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
     ggtitle("Predicting Gas Mileage") +
     theme(plot.title = element_text(face="bold"),
           legend.justification=c(1, 1), legend.position=c(1, 1),
           legend.background = element_rect(colour="grey80"),
           legend.title = element_blank()) 

# Create list of brackets (label, topmost included predictor, bottommost included predictor)
three_brackets <- list(c("Overall", "wt", "wt"), c("Engine", "cyl", "hp"),
                       c("Transmission", "gear", "am"))

g456 <- p456 %>% add_brackets(three_brackets)

grid.draw(g456)  # to display

# pdf("plot.pdf")  # to save to file (not run)
# grid.draw(g456)
# dev.off()
```

An alternate use of dot-and-whisker plots is to compare the estimated coefficients for a single predictor across many models or datasets: Andrew Gelman calls such plots "[the secret weapon](http://andrewgelman.com/2005/03/07/the_secret_weap/)."  They are easy to make with the `secret_weapon` function.

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
data(diamonds)

# Estimate models for many subsets of data, put results in a tidy data.frame
by_clarity <- diamonds %>% group_by(clarity) %>%
 do(tidy(lm(price ~ carat + cut + color, data = .))) %>%
 ungroup %>% rename(model = clarity)

# Deploy the secret weapon
secret_weapon(by_clarity, "carat") +
    xlab("Estimated Coefficient (Dollars)") + ylab("Diamond Clarity") +
    ggtitle("Estimated Coefficients for Diamond Size Across Clarity Grades") +
    theme(plot.title = element_text(face="bold"))
```

A final means of presenting many models' results at once, in a particularly compact format, is the "small multiple" plot. Small multiple plots present estimates in multiple panels, one for each variable: they are similar to a stack of secret weapon plots [see @Kastellec2007, 766].  The `small_multiple` function makes such plots simple.  Here, we pass a tidy data.frame of six models to the function so as to be able to rescale the coefficients and to exclude the intercept, but the function can accept a list of model objects as well.

```{r fig.width= 2.5, fig.height=6.5, warning=FALSE, message=FALSE}
# Generate a tidy data.frame of regression results from six models
m <- list()
ordered_vars <- c("wt", "cyl", "disp", "hp", "gear", "am")
m[[1]] <- lm(mpg ~ wt, data = mtcars) 
m123456_df <- m[[1]] %>% tidy %>% by_2sd(mtcars) %>%
  filter(term != "(Intercept)") %>% mutate(model = "Model 1")
for (i in 2:6) {
  m[[i]] <- update(m[[i-1]], paste(". ~ . +", ordered_vars[i]))
  m123456_df <- rbind(m123456_df, m[[i]] %>% tidy %>% by_2sd(mtcars) %>%
    filter(term != "(Intercept)") %>% mutate(model = paste("Model", i)))
}

# Relabel predictors (will appear as facet labels)
m123456_df <- m123456_df %>% 
  relabel_predictors(c(wt = "Weight",
                     cyl = "Cylinder",
                     disp = "Displacement",
                     hp = "Horsepower",
                     gear = "Gears",
                     am = "Manual"))
 
# Generate a 'small multiple' plot
small_multiple(m123456_df) +
  theme_bw() + xlab("Coefficient Estimate") +
  geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
  ggtitle("Predicting Gas Mileage") +
  theme(plot.title = element_text(face = "bold"), legend.position = "none",
    axis.text.x  = element_text(angle = 60, hjust = 1)) 

```

## Conclusion

The `dotwhisker` package provides a flexible and convenient way to visualize and compare estimates across various models. This vignette offers an overview of its use and features. We encourage users to consult the help files for more details. 

The development of the package is ongoing (among other things, we are working to enable small multiples plots to have separate y-axes for each predictor).  Please contact us with any questions, bug reports, and comments.

## Affiliation

Frederick Solt

Department of Political Science,

University of Iowa, 

324 Schaeffer Hall,

20 E Washington St, Iowa City, IA, 52242

Email: <frederick-solt@uiowa.edu>

Website: <http://myweb.uiowa.edu/fsolt>

<br></br>

Yue Hu

Department of Political Science,

University of Iowa, 

313 Schaeffer Hall,

20 E Washington St, Iowa City, IA, 52242

Email: <yue-hu-1@uiowa.edu>

Website: <http://clas.uiowa.edu/polisci/people/yue-hu>

## References

