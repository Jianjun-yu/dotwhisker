#' Add a Labelled Bracket to Group Predictors in a Dot-and-Whisker Plot
#'
#' \code{add_bracket} draws a bracket along the y-axis beyond the plotting area of a dot-and-whisker plot generated by \code{dwplot}, useful for labelling a group of predictors
#'
#' @param p A dot-and-whisker plot generated by \code{dwplot}
#' @param label The text to appear on the bracket
#' @param top The name of the topmost variable to be bracketed as a character string, or alternately, the numeric position of this variable, counting from the bottom of the y-axis
#' @param bottom The name of the bottommost variable to be bracketed as a character string, or alternately, the numeric position of this variable, counting from the bottom of the y-axis
#' @param face Options for label text: "plain", "bold", "italic", "oblique", and "bold.italic"
#'
#' @return The function returns a \code{gtable} object, which are viewed with \code{\link[grid.draw]{grid::grid.draw}}.
#'
#' To save, wrap the \code{grid.draw} command with \code{\link[pdf]{pdf}} or \code{\link[png]{png}}, etc., and \code{\link[dev.off]{dev.off}}.  Alternately, the next release of \code{ggplot2} (>1.0.1.9002) will enable \code{ggsave} for \code{gtable}s; one can install the development version using \code{devtools::install_github("hadley/ggplot2")}.
#'
#' @examples
#' library(broom)
#' library(dotwhisker)
#' 
#' data(mtcars)
#' m1 <- lm(mpg ~ wt + cyl + disp, data = mtcars)
#' m1_df <- tidy(m1) # create data.frame of regression results
#'
#' p <- dwplot(m1_df) +
#'     scale_y_discrete(breaks = 4:1, labels=c("Intercept", "Weight", "Cylinders", "Displacement")) +
#'     theme_bw() + xlab("Coefficient") + ylab("") +
#'     geom_vline(xintercept = 0, colour = "grey50", linetype = 2) +
#'     theme(legend.position="none")
#'
#' p %>% add_bracket(label="Engine", top="cyl", bottom=1)
#'
#' @import grid gridExtra gtable
#'
#' @export

add_bracket <- function(p, label, top, bottom, face="italic") {
    y_ind <- NULL
    pd <- p$data
    if (is.character(top)) top <- pd$y_ind[which(unique(pd$term)==top)]
    if (is.character(bottom)) bottom <- pd$y_ind[which(unique(pd$term)==bottom)]

    overhang <- max(pd$y_ind)/40
    p1 <- p + theme(plot.margin = unit(c(1, 1, 1, -1), "lines")) + ylab("")

    theme_p2 <- theme_bw()
    theme_p2$line <- element_blank()
    theme_p2$rect <- element_blank()


    n_vars <- length(unique(p$data$term))
    p2 <- ggplot(p$data, aes(x = -1, y = y_ind)) + geom_point() +
        coord_cartesian(ylim = c(.5, n_vars+.5), xlim = c(0, 1)) +
        xlab(p$labels$x) + ylab("") + theme_p2 +
        theme(plot.margin = unit(c(1, -.5, 1, 0), "lines")) +
        scale_x_continuous(expand = c(0,0)) +
        annotation_custom(
            grob = textGrob(label = label, gp = gpar(cex = .7, fontface = face), rot = 90),
            ymin = (top+bottom)/2, ymax = (top+bottom)/2,
            xmin = .3, xmax = .3) +
        annotation_custom(grob = linesGrob(), xmin = .6, xmax = .6, ymin = bottom-overhang, ymax = top+overhang) +
        annotation_custom(grob = linesGrob(), xmin = .6, xmax = 1, ymin = top+overhang, ymax = top+overhang) +
        annotation_custom(grob = linesGrob(), xmin = .6, xmax = 1, ymin = bottom-overhang, ymax = bottom-overhang)

    g1 <- gtable_add_cols(ggplotGrob(p1), unit(1, "cm"), 0)
    g1[["layout"]]$l[g1[["layout"]]$name=="background"] <- 1
    g2 <- gtable_filter(ggplotGrob(p2), pattern = "panel")

    g <- gtable_add_grob(g1, g2, g1[["layout"]]$t[g1[["layout"]]$name=="panel"], 1)
    g <- gtable_add_cols(g, unit(.7, "line"), 0)
    g[["layout"]]$l[g[["layout"]]$name=="background"] <- 1

    grid.draw(g)
    g
}

# until ggplot2 is updated (current dev version works):
#ggsave <- ggplot2::ggsave; body(ggsave) <- body(ggplot2::ggsave)[-2]
