#' Dot-and-Whisker Plots of Regression Coefficients from Tidy Dataframes
#'
#' \code{dwplot} is a
#'
#' @param df A model object including an interaction term, or, alternately, a data frame generated by an earlier call to interplot using the argument plot = FALSE.
#' @param varnames The name (as a string) of the variable of interest in the interaction term; its conditional coefficient estimates will be plotted.
#'
#' @details \code{dwplot} visualizes regression results saved as tidy data.frames by, e.g., \code{\link[broom]{broom::tidy}} as dot-and-whisker plots generated by \code{\link[ggplot2]{ggplot}}.
#'
#' Because the output function is based on \code{\link[ggplot2]{ggplot}}, any additional arguments and layers supported by \code{ggplot2} can be added with the \code{+}.
#'
#' @return The function returns a \code{ggplot} object.
#'
#' @import  ggplot2
#'
#' @examples
#' data(mtcars)
#' m1 <- lm(mpg ~ wt + cyl + disp, data = mtcars)
#' library(broom)
#' library(regcoefplot)
#'
#' m1_df <- tidy(m1) # create data.frame of regression results
#'
#' # Plot regression coefficients
#' dwplot(m1_df)
#'
#' # Make it pretty with ggplot options
#' dwplot(m1_df) +
#'      scale_y_discrete(labels=c("Displacement", "Cylinders", "Weight", "Intercept")) +
#'      theme_bw() + xlab("Coefficient") + ylab("") +
#'      geom_vline(xintercept = 0, colour = "grey50", linetype = 2) +
#'      theme(legend.justification=c(1,0), legend.position=c(1,0))
#' @export

# Some useful keyboard shortcuts for package authoring:
#
#   Build and Reload Package:  'Cmd + Shift + B'
#   Check Package:             'Cmd + Shift + E'
#   Test Package:              'Cmd + Shift + T'

dwplot <- function(df, dodge_size=.25) {

    n_vars <- length(unique(df$term))
    if ("model" %in% names(df)) n_models <- length(unique(df$model)) else {
        if (length(df$term) == n_vars) {
            df$model <- "df"
            n_models <- 1
        } else stop("Please add a variable named \'model\' to distinguish different models")
    }
    m_names <- unique(df$model)
    v_names <- df$term

    y_ind <- rep(seq(n_vars, 1), n_models)
    df$y_ind <- y_ind

    if (n_models==1) shift <- 0 else
        if (n_models==2) shift <- c(rep(dodge_size, n_vars), rep(-dodge_size, n_vars)) else
            if (n_model==3) shift <- c(rep(dodge_size, n_vars), rep(0, n_vars), rep(-dodge_size, n_vars)) else
                stop('No more than three models can be plotted at once.')
    df$shift <- shift

    p <- ggplot(df, aes(x = estimate, y = y_ind+shift, colour=factor(model))) +
        geom_point() +
        geom_segment(aes(x = estimate-qnorm(.975)*std.error, xend = estimate+qnorm(.975)*std.error,
                         y = y_ind+shift, yend = y_ind+shift,
                         colour=factor(model))) +
        scale_y_discrete(breaks=y_ind, labels=v_names) +
        coord_cartesian(ylim=c(.5, n_vars+.5))

    return(p)
}
