#' Dot-and-Whisker Plots of Regression Coefficients from Tidy Data Frames
#'
#' \code{dwplot} is a function for quickly and easily generating dot-and-whisker plots of regression models saved in tidy data frames.
#'
#' @param df A data.frame including the variables \code{term} (names of independent variables), \code{estimate} (corresponding coefficient estimates), \code{std.error} (corresponding standard errors), and optionally \code{model} (when multiple models are desired on a single plot) such as generated those by \code{\link[broom]{broom::tidy}}.
#' @param dodge_size A number (typically between 0 and 0.3) indicating how much vertical separation should be between different models' coefficients when multiple models are graphed in a single plot.  Lower values tend to look better when the number of independent variables is small.
#'
#' @details \code{dwplot} visualizes regression results saved in tidy data.frames by, e.g., \code{\link[broom]{broom::tidy}} as dot-and-whisker plots generated by \code{\link[ggplot2]{ggplot}}.
#'
#' Because the function takes a data.frame as input, it is easily employed for a wide range of models, and because the output is a \code{ggplot} object, it can be further customized with any additional arguments and layers supported by \code{ggplot2}.
#'
#' @return The function returns a \code{ggplot} object.
#'
#' @import  ggplot2
#'
#' @examples
#'
#' library(broom)
#' library(dotwhisker)
#'
#' # Plot regression coefficients from a single model
#' data(mtcars)
#' m1 <- lm(mpg ~ wt + cyl + disp, data = mtcars)
#' m1_df <- tidy(m1) # create data.frame of regression results
#'
#'dwplot(m1_df) +
#'     scale_y_discrete(breaks = 4:1, labels=c("Intercept", "Weight", "Cylinders", "Displacement")) +
#'     theme_bw() + xlab("Coefficient") + ylab("") +
#'     geom_vline(xintercept = 0, colour = "grey50", linetype = 2) +
#'     theme(legend.position="none")
#'
#' # Plot regression coefficients from multiple models
#' library(dplyr)
#' by_trans <- mtcars %>% group_by(am) %>%
#'     do(tidy(lm(mpg ~ wt + cyl + disp, data = .))) %>% rename(model=am)
#'
#' dwplot(by_trans, dodge_size = .05) +
#'     scale_y_discrete(breaks = 4:1, labels=c("Intercept", "Weight", "Cylinders", "Displacement")) +
#'     theme_bw() + xlab("Coefficient Estimate") + ylab("") +
#'     geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
#'     ggtitle("Predicting Gas Mileage, OLS Estimates") +
#'     theme(plot.title = element_text(face="bold"),
#'           legend.justification=c(1,0), legend.position=c(1,0),
#'           legend.background = element_rect(colour="grey80"),
#'           legend.title.align = .5) +
#'     scale_colour_grey(start = .4, end = .8,
#'                       name = "Transmission",
#'                       breaks = c(0, 1),
#'                       labels = c("Automatic", "Manual"))
#' @export

dwplot <- function(df, dodge_size=.15) {

    n_vars <- length(unique(df$term))
    if ("model" %in% names(df)) n_models <- length(unique(df$model)) else {
        if (length(df$term) == n_vars) {
            df$model <- "df"
            n_models <- 1
        } else stop("Please add a variable named \'model\' to distinguish different models")
    }
    m_names <- unique(df$model)
    v_names <- df$term

    y_ind <- rep(seq(n_vars, 1), n_models)
    df$y_ind <- y_ind

    if (n_models==1) shift <- 0 else
        if (n_models==2) shift <- c(rep(dodge_size, n_vars), rep(-dodge_size, n_vars)) else
            if (n_model==3) shift <- c(rep(dodge_size, n_vars), rep(0, n_vars), rep(-dodge_size, n_vars)) else
                stop('No more than three models can be plotted at once.')
    df$shift <- shift

    p <- ggplot(df, aes(x = estimate, y = y_ind+shift, colour=factor(model))) +
        geom_point() +
        geom_segment(aes(x = estimate-qnorm(.975)*std.error, xend = estimate+qnorm(.975)*std.error,
                         y = y_ind+shift, yend = y_ind+shift,
                         colour=factor(model))) +
        scale_y_discrete(breaks=y_ind, labels=v_names) +
        coord_cartesian(ylim=c(.5, n_vars+.5))

    return(p)
}
